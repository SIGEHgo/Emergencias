"centros_de_acopio",
"albergues_y_refugios",
"comedores_comunitarios_en_operacion",
"escuelas_seph_2025",
"universidades_estatales",
"caics_2024",
"tiendas_diconsa"
)
Lista_BUIG = Lista_BUIG[Lista_BUIG %in% lista_interes]
faltantes = lista_interes[!lista_interes %in% Lista_BUIG]
server <- function(input, output, session) {
#source("../../../Reutilizables/Postgres_BUIG/conexion_buig.R")
rv_config <- reactiveValues(CAPA_CONFIG_DATA = CAPA_CONFIG)
INPUT_TO_KEY_MAP <- list(
capa_base_g1 = paste0("g1_c", 1:5),
capa_dem_g2 = paste0("g2_c", 1:3),
capa_hid_g3 = paste0("g3_c", 1:5),
capa_hid_g4 = paste0("g4_c", 1:5),
capa_vial_g5 = paste0("g5_c", 1:4),
capa_infra_g6 = paste0("g6_c", 1:6),
capa_poi_g7 = paste0("g7_c", 1:7)
)
#Función para encontrar el ID del input padre a partir del layer_key
find_parent_input_id <- function(layer_key) {
for (id in names(INPUT_TO_KEY_MAP)) {
if (layer_key %in% INPUT_TO_KEY_MAP[[id]]) {
return(id)
}
}
return(NULL)
}
ALL_LAYER_KEYS <- names(CAPA_CONFIG)
selected_layers_vector <- reactive({
active_layers <- character(0)
for (layer_key in ALL_LAYER_KEYS) {
checkbox_id <- paste0(layer_key, "_chk")
if (isTRUE(input[[checkbox_id]])) {
active_layers <- c(active_layers, layer_key)
}
}
return(active_layers)
})
# Almacena el estado de las capas activas del ciclo anterior
v <- reactiveValues(selected = character(0))
# Inicialización del Mapa Base
output$mapa_principal <- renderLeaflet({
leaflet() |>
addTiles() |>
setView(lng = -98, lat = 20, zoom = 6) |>
addLayersControl(
options = layersControlOptions(collapsed = FALSE)
) |> addDrawToolbar(
targetGroup = "Seleccion del usuario",
editOptions = editToolbarOptions(
selectedPathOptions = selectedPathOptions()
),
circleMarkerOptions = F,polylineOptions = F,
toolbar = toolbarOptions(
actions = list(title = "Cancel drawing", text = "Cancelar selección"),
finish = list(title = "Finish drawing", text = "Terminar selección"),
undo = list(title = "Delete last point drawn", text = "Borrar último punto"),
buttons = list(polyline = "Draw a polyline", polygon = "Dibujar un Polígono", rectangle =
"Dibujar un rectángulo", circle = "Dibujar un círculo", marker = "Dibujar un Marcador", circlemarker
= "Draw a circlemarker")
),
edittoolbar = edittoolbarOptions(
actions = list(save = list(title = "Save changes", text = "Guardar cambios"), cancel = list(title
= "Cancel editing, discards all changes", text = "Cancelar"), clearAll = list(title =
"Clear all layers", text = "Borrar todas las capas")),
buttons = list(edit = "Editar Capas", editDisabled = "No hay capas para editar", remove =
"Borrar Capas", removeDisabled = "No hay capas para borrar")
)
) |>
addLayersControl(
overlayGroups = c("Seleccion del usuario"),
options = layersControlOptions(collapsed = FALSE)
) #|>addStyleEditor()
})
# Vector de capas seleccionadas
# selected_layers_vector <- reactive({
#   c(input$capa_base_g1, input$capa_dem_g2, input$capa_hid_g3,
#     input$capa_hid_g4, input$capa_vial_g5, input$capa_infra_g6,
#     input$capa_poi_g7)
# })
observeEvent(input$mapa_principal_draw_new_feature, {
draw_input <- input$mapa_principal_draw_new_feature
print("El usuario hizo un dibujito")
#print(draw_input)
feature_type <- draw_input$properties$feature_type
Poligono <- switch(feature_type,
"marker" = NULL,
"circle" = {
geojsonsf::geojson_sf(jsonify::to_json(draw_input$geometry, unbox = T)) |>
sf::st_buffer( dist = draw_input$properties$radius)
},
"polygon" = {
geojsonsf::geojson_sf(jsonify::to_json(draw_input$geometry, unbox = T))
},
"rectangle" = {
geojsonsf::geojson_sf(jsonify::to_json(draw_input$geometry, unbox = T))
},
NULL
)
if (!is.null(Poligono)) {
Area_Delimitada <- Calcular_Interseccion(poligono = Poligono, base_pob = base_pob_default)
poblacion_total_estimada <- sum(Area_Delimitada$POB_Proporcional, na.rm = TRUE)
viviendas_total_estimada <- sum(Area_Delimitada$VIV_Proporcional, na.rm = TRUE)
popup_content <- paste0(
"<strong>Población Estimada:</strong> ",
format(round(poblacion_total_estimada, 0), big.mark = ","), " habitantes"
# ,"<br>",
# "<strong>Viviendas Estimadas:</strong> ",
# format(round(viviendas_total_estimada, 0), big.mark = ","), " viviendas"
)
centroide_sf <- sf::st_centroid(Poligono)
coords <- sf::st_coordinates(centroide_sf)
proxy <- leaflet::leafletProxy("mapa_principal")
proxy |>
leaflet::addPopups(
lng = coords[1, "X"], # Longitud
lat = coords[1, "Y"], # Latitud
popup = popup_content,
options = leaflet::popupOptions(closeButton = TRUE,closeOnClick = F)
)
}
})
rv_map_params <- rv_config
ALL_BUTTON_KEYS <- names(CAPA_CONFIG)  # Lista de todas las capas
ALL_BUTTON_INPUTS <- paste0(ALL_BUTTON_KEYS, "_btn") # Lista de IDs de input
ALL_SAVE_BUTTONS=paste0("modal_",ALL_BUTTON_KEYS,"_save")
#Igual g1_c2
rv_click_state <- reactiveValues()
rv_save_state <- reactiveValues()
# Inicializar con 0s
for (btn_id in ALL_BUTTON_INPUTS) {
rv_click_state[[btn_id]] <- 0
}
for (btn_id in ALL_SAVE_BUTTONS) {
rv_save_state[[btn_id]] <- 0
}
observeEvent({
sapply(ALL_BUTTON_INPUTS, function(id) input[[id]])
}, {
culprit_key <- NULL
for (layer_key in ALL_BUTTON_KEYS) {
btn_id <- paste0(layer_key, "_btn")
current_click_count <- input[[btn_id]]
previous_click_count <- isolate(rv_click_state[[btn_id]])
if (current_click_count > previous_click_count) {
culprit_key <- layer_key
rv_click_state[[btn_id]] <- current_click_count
break
}
}
if (!is.null(culprit_key)) {
current_config <- rv_config$CAPA_CONFIG_DATA[[culprit_key]]
print(current_config)
showModal(config_modal(culprit_key, current_config$name, current_config$color))
colourpicker::updateColourInput(session, paste0("modal_", culprit_key, "_col"), value = current_config$color)
updateSliderInput(session, paste0("modal_", culprit_key, "_size"), value = current_config$size)
}
}, ignoreInit = TRUE)
observeEvent({
sapply(ALL_SAVE_BUTTONS, function(id) input[[id]])
}, {
culprit_key <- NULL
for (layer_key in ALL_BUTTON_KEYS) {
save_btn_id <- paste0("modal_", layer_key, "_save")
current_save_count <- ifelse(is.null(input[[save_btn_id]]),
0,
input[[save_btn_id]])
previous_save_count <- isolate(rv_save_state[[save_btn_id]])
if (current_save_count > previous_save_count) {
culprit_key <- layer_key
rv_save_state[[save_btn_id]] <- current_save_count
break
}
}
if (!is.null(culprit_key)) {
modal_col_id <- paste0("modal_", culprit_key, "_col")
modal_size_id <- paste0("modal_", culprit_key, "_size")
rv_config$CAPA_CONFIG_DATA[[culprit_key]]$color <- input[[modal_col_id]]
rv_config$CAPA_CONFIG_DATA[[culprit_key]]$size <- input[[modal_size_id]]
removeModal()
##Y actualizamos el leafletproxy. No hay que usar más informacion, solo borramos la capa, y la agregamos con el nuevo color
#culprit_key
group=find_parent_input_id(culprit_key)
#Removegroup
proxy = leafletProxy("mapa_principal", session)
proxy |>  clearGroup(group = culprit_key)
#Agregamos grupo
data_para_agregar=rv_config$CAPA_CONFIG_DATA[[culprit_key]]$data
geom_type <- as.character(unique(st_geometry_type(data_para_agregar)))[1]
if (geom_type %in% c("POLYGON", "MULTIPOLYGON")) {
proxy |> addPolygons(data = data_para_agregar, fillColor =input[[modal_col_id]], color = input[[modal_col_id]],weight=input[[modal_size_id]], fillOpacity = 0.7, group = layer_key,popup=popup_general(data_para_agregar) |> as.character())
} else if (geom_type %in% c("LINESTRING", "MULTILINESTRING")) {
proxy |> addPolylines(data = data_para_agregar, color = input[[modal_col_id]],weight=input[[modal_size_id]], opacity = 0.8, group = layer_key,popup=popup_general(data_para_agregar)|> as.character())
} else if (geom_type %in% c("POINT", "MULTIPOINT")) {
proxy |> addCircleMarkers(data = data_para_agregar, radius = input[[modal_size_id]], color = input[[modal_col_id]], fillOpacity = 0.9, group = layer_key,popup=popup_general(data_para_agregar)|> as.character())
}
}
}, ignoreInit = TRUE)
observe({
current_layers <- selected_layers_vector()
previous_layers <- v$selected
proxy = leafletProxy("mapa_principal", session)
layers_to_add = setdiff(current_layers, previous_layers)
layers_to_remove = setdiff(previous_layers, current_layers)
print(layers_to_remove)
for (layer_key in layers_to_remove) {
proxy |>  clearGroup(group = layer_key)
}
successful_layers = setdiff(previous_layers, layers_to_remove)
for (layer_key in layers_to_add) {
#print(rv_config$CAPA_CONFIG_DATA[[layer_key]])
config <- rv_config$CAPA_CONFIG_DATA[[layer_key]]
cat("Estamos imprimiendo config")
print(config)
if (is.null(config)) next
tryCatch({
#load_layer_data(layer_key)
if (rv_config$CAPA_CONFIG_DATA[[layer_key]]$data |> is.null()) {
print("Se lee desde el buig")
print(config$nombre_buig)
#data_sf <- load_layer_data(buig = buig, nombre_buig = config$nombre_buig, columnas_interes = )
data_sf = read_sf(buig, config$nombre_buig)
#data_sf <-st_read(paste0("Inputs/",config$nombre_buig,".geojson")) |> dplyr::filter(!st_is_empty(geometry)) #load_layer_data(buig = buig,
#               nombre_buig =  config$nombre_buig,
#              columnas_interes = config$cols,
#             custom_filter = ifelse(config$custom_filter |> is.null(),'',config$custom_filter))###Aqui se ve a cambiar por la función custom de dplyr.
rv_config$CAPA_CONFIG_DATA[[layer_key]]$data <- data_sf
} else {
print("Se lee desde local ")
data_sf <- rv_config$CAPA_CONFIG_DATA[[layer_key]]$data
}
geom_type <- as.character(unique(st_geometry_type(data_sf)))[1]
if (geom_type %in% c("POLYGON", "MULTIPOLYGON")) {
proxy |> addPolygons(data = data_sf, fillColor = rv_config$CAPA_CONFIG_DATA[[layer_key]]$color, color = "black", weight = rv_config$CAPA_CONFIG_DATA[[layer_key]]$size, fillOpacity = 0.7, group = layer_key,popup=popup_general(data_sf)|> as.character())
} else if (geom_type %in% c("LINESTRING", "MULTILINESTRING")) {
proxy |> addPolylines(data = data_sf, color = rv_config$CAPA_CONFIG_DATA[[layer_key]]$color, weight = rv_config$CAPA_CONFIG_DATA[[layer_key]]$size, opacity = 0.8, group = layer_key,popup=popup_general(data_sf)|> as.character())
} else if (geom_type %in% c("POINT", "MULTIPOINT")) {
proxy |> addCircleMarkers(data = data_sf, radius = rv_config$CAPA_CONFIG_DATA[[layer_key]]$size, color = rv_config$CAPA_CONFIG_DATA[[layer_key]]$color, fillOpacity = 0.9, group = layer_key,popup=popup_general(data_sf)|> as.character())
}
successful_layers <- c(successful_layers, layer_key)
}, error = function(e) {
print(paste("ERROR:", e$message))
showNotification(
ui = HTML(paste("<strong>Error de Carga:</strong> No se pudo cargar la capa <b>", config$nombre_buig, "</b>.",
"Por favor, verifique la conexión o el nombre de la tabla. ")),
type = "error",
duration = 2
)
parent_input_id <- find_parent_input_id(layer_key)
if (!is.null(parent_input_id)) {
current_selection_in_group <- input[[parent_input_id]]
new_selection <- current_selection_in_group[current_selection_in_group != layer_key]
updateCheckboxGroupInput(session, parent_input_id, selected = new_selection)
}
})
}
v$selected <- successful_layers %>% unique()
}) # Fin del observe
}
shinyApp(ui, server)
dplyr::tbl(buig, "Estructuras_elevadas")
buig <- pool::dbPool(
drv = RPostgres::Postgres(),
dbname = db_name,
host = db_host,
port = db_port,
user = db_user,
password = db_pass
)
onStop(function() {
print("Desconexion del servidor")
pool::poolClose(buig)
print(buig)
})
df = dplyr::tbl(buig, "Estructuras_elevadas")
df
df = dplyr::tbl(buig, "Estructuras_elevadas") |> dplyr::collect() |> dplyr::mutate(geom = sf::st_as_sfc(geom, EWKB = TRUE))
View(df)
coordenadas = sf::st_coordinates(datos$geom[1])[1,1]
coordenadas = sf::st_coordinates(df$geom[1])[1,1]
coordenadas
if (coordenadas > 30) {
datos = datos |> sf::st_as_sf(crs = 32614) |> sf::st_transform(crs = 4326) |> sf::st_zm()
} else {
datos = datos |> sf::st_as_sf(crs = 4326) |> sf::st_zm()
}
df = dplyr::tbl(buig, "Estructuras_elevadas") |> dplyr::collect() |> dplyr::mutate(geom = sf::st_as_sfc(geom, EWKB = TRUE))
coordenadas = sf::st_coordinates(df$geom[1])[1,1]
if (coordenadas > 30) {
df = df |> sf::st_as_sf(crs = 32614) |> sf::st_transform(crs = 4326) |> sf::st_zm()
} else {
df = df |> sf::st_as_sf(crs = 4326) |> sf::st_zm()
}
View(df)
leaflet() |>
addTiles() |>
addMarkers(data = df)
Lista_BUIG
df = dplyr::tbl(buig, "Estructuras_elevadas") |> dplyr::collect() |> dplyr::mutate(geom = sf::st_as_sfc(geom, EWKB = TRUE))
View(df)
coordenadas = sf::st_coordinates(df$geom[1])[1,1]
if (coordenadas > 30) {
df = df |> sf::st_as_sf(crs = 32614) |> sf::st_transform(crs = 4326) |> sf::st_zm()
} else {
df = df |> sf::st_as_sf(crs = 4326) |> sf::st_zm()
}
View(df)
class(sf)
class(df)
DBI::dbDisconnect()
DBI::dbDisconnect(buig)
db_user = 'citnovaconsulta'
buig <- pool::dbPool(
drv = RPostgres::Postgres(),
dbname = db_name,
host = db_host,
port = db_port,
user = db_user,
password = db_pass
)
onStop(function() {
print("Desconexion del servidor")
pool::poolClose(buig)
print(buig)
})
dplyr::tbl(buig, "Estructuras_elevadas") |> dplyr::collect()
dplyr::tbl(buig, "Estructuras_elevadas") |> dplyr::collect() |> dplyr::mutate(geom = sf::st_as_sfc(geom, EWKB = TRUE))
df = dplyr::tbl(buig, "Estructuras_elevadas") |> dplyr::collect() |> dplyr::mutate(geom = sf::st_as_sfc(geom, EWKB = TRUE))
coordenadas = sf::st_coordinates(df$geom[1])[1,1]
if (coordenadas > 30) {
df = df |> sf::st_as_sf(crs = 32614) |> sf::st_transform(crs = 4326) |> sf::st_zm()
} else {
df = df |> sf::st_as_sf(crs = 4326) |> sf::st_zm()
}
leaflet() |>
addTiles() |>
addMarkers(data = df)
View(df)
leaflet() |>
addTiles() |>
addCircleMarkers(data = df)
load_layer_data = function(buig, nombre_buig = "Estructuras_elevadas") {
if (is.null(columnas_interes) || length(columnas_interes) == 0 || columnas_interes == "") {
datos = dplyr::tbl(buig, nombre_buig)
} else {
datos = dplyr::tbl(buig, nombre_buig) |> dplyr::select(all_of(columnas_interes))
}
if ("the_geom" %in% columnas_interes) {
datos = datos |>
dplyr::rename(geom = the_geom)
} else if ("geometry" %in% columnas_interes) {
datos = datos |>
dplyr::rename(geom = geometry)
}
datos = datos |> dplyr::collect() |> dplyr::mutate(geom = sf::st_as_sfc(geom, EWKB = TRUE))
coordenadas = sf::st_coordinates(datos$geom[1])[1,1]
if (coordenadas > 30) {
datos = datos |> sf::st_as_sf(crs = 32614) |> sf::st_transform(crs = 4326) |> sf::st_zm()
} else {
datos = datos |> sf::st_as_sf(crs = 4326) |> sf::st_zm()
}
return(datos |> dplyr::filter(!st_is_empty(geom)))
}
d = load_layer_data()
load_layer_data = function(buig, nombre_buig = "Estructuras_elevadas", columnas_interes = c("geografico", "tipo", "geom")) {
if (is.null(columnas_interes) || length(columnas_interes) == 0 || columnas_interes == "") {
datos = dplyr::tbl(buig, nombre_buig)
} else {
datos = dplyr::tbl(buig, nombre_buig) |> dplyr::select(all_of(columnas_interes))
}
if ("the_geom" %in% columnas_interes) {
datos = datos |>
dplyr::rename(geom = the_geom)
} else if ("geometry" %in% columnas_interes) {
datos = datos |>
dplyr::rename(geom = geometry)
}
datos = datos |> dplyr::collect() |> dplyr::mutate(geom = sf::st_as_sfc(geom, EWKB = TRUE))
coordenadas = sf::st_coordinates(datos$geom[1])[1,1]
if (coordenadas > 30) {
datos = datos |> sf::st_as_sf(crs = 32614) |> sf::st_transform(crs = 4326) |> sf::st_zm()
} else {
datos = datos |> sf::st_as_sf(crs = 4326) |> sf::st_zm()
}
return(datos |> dplyr::filter(!st_is_empty(geom)))
}
d = load_layer_data()
load_layer_data = function(buig, nombre_buig = "Estructuras_elevadas", columnas_interes = c("")) {
if (is.null(columnas_interes) || length(columnas_interes) == 0 || columnas_interes == "") {
datos = dplyr::tbl(buig, nombre_buig)
} else {
datos = dplyr::tbl(buig, nombre_buig) |> dplyr::select(all_of(columnas_interes))
}
if ("the_geom" %in% columnas_interes) {
datos = datos |>
dplyr::rename(geom = the_geom)
} else if ("geometry" %in% columnas_interes) {
datos = datos |>
dplyr::rename(geom = geometry)
}
datos = datos |> dplyr::collect() |> dplyr::mutate(geom = sf::st_as_sfc(geom, EWKB = TRUE))
coordenadas = sf::st_coordinates(datos$geom[1])[1,1]
if (coordenadas > 30) {
datos = datos |> sf::st_as_sf(crs = 32614) |> sf::st_transform(crs = 4326) |> sf::st_zm()
} else {
datos = datos |> sf::st_as_sf(crs = 4326) |> sf::st_zm()
}
return(datos |> dplyr::filter(!st_is_empty(geom)))
}
d = load_layer_data()
d = load_layer_data(buig = buig, nombre_buig = "Estructuras_elevadas")
View(d)
db_host = 'sigmapdb.csedvatdfhkw.us-west-2.rds.amazonaws.com'
db_user = 'citnovaconsulta'
db_pass = "Password2025"
db_port = 5432
db_name = 'geo_citnova'
buig <- pool::dbPool(
drv = RPostgres::Postgres(),
dbname = db_name,
host = db_host,
port = db_port,
user = db_user,
password = db_pass
)
onStop(function() {
print("Desconexion del servidor")
pool::poolClose(buig)
print(buig)
})
Lista_BUIG = pool::dbListTables(buig) |> as.list()
load_layer_data = function(buig, nombre_buig = "Estructuras_elevadas", columnas_interes = c("geografico", "tipo", "geom")) {
if (is.null(columnas_interes) || length(columnas_interes) == 0 || columnas_interes == "") {
datos = dplyr::tbl(buig, nombre_buig)
} else {
datos = dplyr::tbl(buig, nombre_buig) |> dplyr::select(all_of(columnas_interes))
}
if ("the_geom" %in% columnas_interes) {
datos = datos |>
dplyr::rename(geom = the_geom)
} else if ("geometry" %in% columnas_interes) {
datos = datos |>
dplyr::rename(geom = geometry)
}
datos = datos |> dplyr::collect() |> dplyr::mutate(geom = sf::st_as_sfc(geom, EWKB = TRUE))
coordenadas = sf::st_coordinates(datos$geom[1])[1,1]
if (coordenadas > 30) {
datos = datos |> sf::st_as_sf(crs = 32614) |> sf::st_transform(crs = 4326) |> sf::st_zm()
} else {
datos = datos |> sf::st_as_sf(crs = 4326) |> sf::st_zm()
}
return(datos |> dplyr::filter(!st_is_empty(geom)))
}
d = load_layer_data(buig = buig, nombre_buig = "Estructuras_elevadas")
d = load_layer_data(buig = buig, nombre_buig = "Estructuras_elevadas", columnas_interes = c(""))
View(d)
d = load_layer_data(buig = buig, nombre_buig = "Estructuras_elevadas", columnas_interes = c("geografico", "tipo", "geom"))
View(load_layer_data)
load_layer_data = function(buig, nombre_buig = "Estructuras_elevadas", columnas_interes = c("geografico", "tipo", "geom")) {
if (is.null(columnas_interes) || length(columnas_interes) == 0 || any(columnas_interes == "")) {
datos = dplyr::tbl(buig, nombre_buig)
} else {
datos = dplyr::tbl(buig, nombre_buig) |> dplyr::select(all_of(columnas_interes))
}
if ("the_geom" %in% columnas_interes) {
datos = datos |>
dplyr::rename(geom = the_geom)
} else if ("geometry" %in% columnas_interes) {
datos = datos |>
dplyr::rename(geom = geometry)
}
datos = datos |> dplyr::collect() |> dplyr::mutate(geom = sf::st_as_sfc(geom, EWKB = TRUE))
coordenadas = sf::st_coordinates(datos$geom[1])[1,1]
if (coordenadas > 30) {
datos = datos |> sf::st_as_sf(crs = 32614) |> sf::st_transform(crs = 4326) |> sf::st_zm()
} else {
datos = datos |> sf::st_as_sf(crs = 4326) |> sf::st_zm()
}
return(datos |> dplyr::filter(!st_is_empty(geom)))
}
d = load_layer_data(buig = buig, nombre_buig = "Estructuras_elevadas", columnas_interes = c("geografico", "tipo", "geom"))
View(d)
load_layer_data = function(buig, nombre_buig = "Estructuras_elevadas", columnas_interes = c("geografico", "tipo", "geom")) {
if (is.null(columnas_interes) || length(columnas_interes) == 0 || any(columnas_interes == "")) {
datos = dplyr::tbl(buig, nombre_buig)
} else {
datos = dplyr::tbl(buig, nombre_buig) |> dplyr::select(all_of(columnas_interes))
}
if ("the_geom" %in% columnas_interes) {
datos = datos |>
dplyr::rename(geom = the_geom)
} else if ("geometry" %in% columnas_interes) {
datos = datos |>
dplyr::rename(geom = geometry)
}
datos = datos |> dplyr::collect() |> dplyr::mutate(geom = sf::st_as_sfc(geom, EWKB = TRUE))
coordenadas = sf::st_coordinates(datos$geom[1])[1,1]
if (coordenadas > 30) {
datos = datos |> sf::st_as_sf(crs = 32614) |> sf::st_transform(crs = 4326) |> sf::st_zm()
} else {
datos = datos |> sf::st_as_sf(crs = 4326) |> sf::st_zm()
}
return(datos |> dplyr::filter(!st_is_empty(geom)))
}
a = load_layer_data()
a = load_layer_data(buig = buig)
View(a)
a = load_layer_data(buig = buig, nombre_buig = "hospitales_hgo_gral")
